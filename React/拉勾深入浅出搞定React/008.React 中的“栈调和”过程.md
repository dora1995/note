虽然react15相对16或17已经黯然失色，但仍有**去了解和学习的价值**

> 以史为镜，可以知兴替 + 学习知识需要建立必要且完整的上下文

> 如果我们不清楚 React 15 的运作机制，就无从把握它的局限性；如果我们不能确切地把握 React 15 的局限性，就无法从根本上理解 React 16 大改版背后的设计动机。因此在追逐时代潮流之前，必须学好历史

### 调和过程

概念解析：“调和”又译为“协调”，协调过程的官方定义，藏在 React 官网对虚拟 DOM 这一概念的解释中
> Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作协调（调和）

通过如 ReactDOM 等类库使虚拟 DOM 与“真实的” DOM 同步，这一过程叫作协调（调和）；


也就是将虚拟DOM映射到真实DOM的过程，但不能画等号；调和是“使一致”；diff是“找不同”，是“使一致”过程中的一个环节


React 的源码结构佐证了这一点：
React 从大的板块上将源码划分为了 Core、Renderer 和 Reconciler 三部分。其中 Reconciler（调和器）的源码位于src/renderers/shared/stack/reconciler这个路径，调和器所做的工作是一系列的，包括**组件的挂载、卸载、更新等过程，其中更新过程涉及对 Diff 算法的调用**

不过在如今大众的认知里，在我们讨论调和的时候，一般都是在讨论diff，因为diff是调和过程中最具有代表性的一环：

根据diff实现形式的不同，调和过程被划分成了以**react15为代表的“栈调和”和react16以来的“fiber调和”**

### 理解React15的“栈调和”调和算法

#### diff策略的设计思想
diff算法其实就是“找不同”的过程，在计算机科学领域，要想找出两个树结构之间的不同, 传统的计算方法是通过循环递归进行树节点的一一对比,  这个过程的算法复杂度是 O (n3) 。尽管这个算法本身已经是几代程序员持续优化的结果，但对计算能力有限的浏览器来说，O (n3) 仍然意味着一场性能灾难

Q：为什么传统的树节点对比是O（n3）
A：有论文专门写的，待细看

因此react团队结合设计层面的一些推导，总结以下规律，将 O (n3)复杂度转为 O (n)复杂度确立的前提：
- 若两个组件属于同一个类型，那么他们将拥有相同的dom树形结构
- 处于同一层级的一组子节点，可以通过设置key作为唯一标识，从而维持各个节点在不同渲染过程中的稳定性

除了这两个“板上钉钉”的规律之外，还有一个和实践结合比较紧密的规律，**它为 React 实现高效的 Diff 提供了灵感：DOM 节点之间的跨层级操作并不多，同层级操作是主流**

#### 把握三个“要点”，图解 Diff 逻辑
对于 Diff 逻辑的拆分与解读，社区目前已经有过许多版本，不同版本的解读姿势和角度各有不同。但说到底，真正需要你把握的要点无非下面这 3 个：
1. Diff 算法性能突破的关键点在于“分层对比”；
2. 类型一致的节点才有继续 Diff 的必要性；
3. key 属性的设置，可以帮我们尽可能重用同一层级内的节点；

1.结合“同层级操作是主流”这一规律，react的diff过程直接放弃了跨层级的节点比较，它只针对相同层级的节点作对比；这样一来，只需要从上到下的一次遍历，就可以完成对整颗树的对比；这是降低复杂度量级方面的一个最重要的设计

但是这样会带来，特殊场景：比如将b节点为根节点的子树从a节点下移动到c节点下，react并不能判断出“移动”行为，而是认为子树一层消失了，从而对应子树销毁；而移入子树的那一层新增了一个组件，则重新为其创建一颗子树

> 销毁+重建的代码是昂贵的，因此官方也建议不要做跨层级的操作，尽量保持dom结构的稳定性

2.减少递归的一刀切策略：类型的一致性决定递归的必要性
结合“若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构”这一规律，react认为只有同类型的组件，才有进一步对比的必要性；若参加diff的两个组件类型不同，那么直接放弃比较，原地替换掉旧的节点；只有确认组件类型相同后，react才会在保留组件对应DOM树的基础上尝试向更深层次去diff

3.key属性帮react记住节点

> key 是用来帮助 React 识别哪些内容被更改、添加或者删除。key 需要写在用数组渲染出来的元素内部，并且需要赋予其一个稳定的值。稳定在这里很重要，因为如果 key 值发生了变更，React 则会触发 UI 的重渲染。这是一个非常有用的特性

它试图解决的是同一层级下节点的重用问题

若没有key的帮助下，在两个子节点（B 和 D）之间插入了一个新的节点（C）。按照已知的 Diff 原则，两棵树之间的 Diff 过程应该是这样的：
- 首先对比位于第 1 层的节点，发现两棵树的节点类型是一致的（都是 A），于是进一步 Diff；
- 开始对比位于第 2 层的节点，第 1 个接受比较的是 B 这个位置，对比下来发现两棵树这个位置上的节点都是 B，没毛病，放过它；
- 第 2 个接受比较的是 D 这个位置，对比 D 和 C，发现前后的类型不一致，直接删掉 D 重建 C；
- 第 3 个接受比较的是 E 这个位置，对比 E 和 D，发现前后的类型不一致，直接删掉 E 重建 D；
- 最后接受“比较”的是树 2 的 E 节点这个位置，这个位置在树 1 里是空的，也就是说树 2 的E 是一个新增节点，所以新增一个 E。

原本d、e是可以直接拿来使用的，明明新增一个节点就能搞定的事，变得反复

在加入key后，当 C 被插入到 B 和 D 之间时，React 并不会再认为 C、D、E 这三个坑位都需要被重建——它会通过识别 ID，意识到 D 和 E 并没有发生变化，而只是被调整了顺序而已。接着，React 便能够轻松地重用它“追踪”到旧的节点，将 D 和 E 转移到新的位置，并完成对 C 的插入。这样一来，同层级下元素的操作成本便大大降低

**请务必确认 key 的唯一和稳定，不要用循环中的index作为标识，若你看了上面的，便知道为什么**



