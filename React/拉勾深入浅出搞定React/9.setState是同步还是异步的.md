```
export default class App extends React.Component{
  state = {
    count: 0
  }
  increment = () => {
    console.log('increment setState前的count', this.state.count)
    this.setState({
      count: this.state.count + 1
    });
    console.log('increment setState后的count', this.state.count)
  }
  triple = () => {
    console.log('triple setState前的count', this.state.count)
    this.setState({
      count: this.state.count + 1
    });
    this.setState({
      count: this.state.count + 1
    });
    this.setState({
      count: this.state.count + 1
    });
    console.log('triple setState后的count', this.state.count)
  }
  reduce = () => {
    setTimeout(() => {
      console.log('reduce setState前的count', this.state.count)
      this.setState({
        count: this.state.count - 1
      });
      console.log('reduce setState后的count', this.state.count)
    },0);
  }
  render(){
    return <div>
      <button onClick={this.increment}>点我增加</button>
      <button onClick={this.triple}>点我增加三倍</button>
      <button onClick={this.reduce}>点我减少</button>
    </div>
  }
}
```

结果是`0 0 1 1 2 1`

Q1：为什么最后一个结果是1

> 正如许许多多的 React 入门教学所声称的那样，“setState 是一个异步的方法”，这意味着当我们执行完 setState 后，state 本身并不会立刻发生改变。 因此紧跟在 setState 后面输出的 state 值，仍然会维持在它的初始状态（0）。在同步代码执行完毕后的某个“神奇时刻”，state 才会“恰恰好”地增加到 1

Q:但这个“神奇时刻”到底何时发生，所谓的“恰恰好”又如何界定呢

### setState异步的动机和原理 - 批量更新的艺术

调用setState后发生的事情：

- （误）shouldComponentupdate - componentWillUpdate - render - componentDidUpdate
- 若setState真每次触发后都re-render，页面很快就卡死了；所以要避免频繁的re-render
- **每来一个 setState，就把它塞进一个队列里“攒起来”。等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。这个过程，叫作“批量更新”**
- 只要同步代码还在执行，那么“收集”操作就不会停止（在同一个方法中多次setState的合并动作并不是单纯地将更新累加，react只会保留最后一次的更新）
- **然后不会立即更新**

Q1的解释：为什么在setTimeout中可以将setState的执行顺序从异步变成同步
结论：并不是setTimeout改变了setState，而是setTimeout帮助setState“逃脱”了react对它的控制；若在react的管控下，一定是异步的



