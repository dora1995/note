https://kaiwu.lagou.com/course/courseInfo.htm?courseId=510#/detail/pc?id=4858

研发模式不断演进的背后，恰恰蕴含着前端人对 “DOM 操作” 这一核心动作的持续思考和改进。而虚拟 DOM，正是先驱们在这个过程中孕育出的一颗明珠

Q：为什么我们需要虚拟DOM

Q：虚拟DOM是什么
A：虚拟DOM（Virtual DOM）本质上是JS和DOM之间的一个映射缓存，**它在形态上表现为一个能够描述DOM结构及其属性信息的JS对象**
即：JS对象，对真实DOM的描述

### React中的虚拟DOM大致是如何工作的

虚拟DOM在React组件的挂载阶段和更新阶段都会作为“关键人物”出镜，其参与流程有：
- 挂载阶段，React结合JSX构建出虚拟DOM，然后通过ReactDOM.render实现虚拟DOM到真是DOM的映射
- 更新阶段，页面变化在作用于真实DOM之前，会先作用于虚拟DOM，将在JS层借助算法对比其改变，然后将这些改变作用于真实DOM中

Q：为什么需要虚拟DOM

Q：虚拟DOM的优势何在

Q：虚拟DOM是否伴随更好的性能

面对上面的问题，你千万不要点对点地去看待问题本身。虚拟DOM相对于过往的DOM操作解决方案来说，是一个新生事物。要想理解一个新生事物存在、发展的合理性，**我们必须将其放在一个足够长的、合理的上下文中去讨论**

上下文，历史中DOM操作的解决方案：
- 原生JS操作DOM，补充DOM
- JQ丰富DOM操作，提高效率
- 原始模版引擎方案的出现（倾向于点对点解决烦琐 DOM 操作的问题）：读取 HTML 模板并解析它，分离出其中的 JS 信息，将解析出的内容拼接成字符串，动态生成 JS 代码，运行动态生成的 JS 代码，吐出“目标 HTML”，将“目标 HTML”赋值给 innerHTML，触发渲染流水线，完成真实 DOM 的渲染
- 数据驱动视图（前三者的升华）

模版引擎的核心问题在于对真实DOM的修改过于大，导致DOM操作的范围过大，频率过高，进而导致糟糕的性能 -> **既然操作真实DOM对性能损耗大，那么我操作假的DOM不就行了**

区别在于多出一层“缓冲区”（数据-虚拟DOM-真实DOM-挂载到页面）：当操作频繁时，会先在虚拟DOM进行对比，定位出具体更新的部分，生成补丁打在需要更新的真实DOM上；即虚拟DOM -> diff -> context -> patch -> 真实DOM

**差量更新可以确保虚拟 DOM 既能够提供高效的开发体验，又能保持过得去的性能**


Q：React选用虚拟DOM，真的是为了更好的性能吗？
A：在整个DOM操作的演化过程中，**主要矛盾并不在于性能，而在于开发者写得爽不爽**，在于研发体验/研发效率。虚拟DOM不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物

> 虚拟DOM并不一定会带来更好的性能，React官方也从来没有把虚拟DOM作为性能层面的卖点对外输出过。虚拟DOM的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的UI编程方式）的同时，仍然保持一个还不错的性能

> 性能问题属于前端领域复杂度比较高的问题。当我们量化性能的时候，往往并不能只追求一个单一的数据，而是需要结合具体的参照物、渲染的阶段、数据的吞吐量等各种要素来作分情况的讨论

```
从图中可以看出，模板渲染的步骤1，和虚拟 DOM 渲染的步骤1、2都属于 JS 范畴的行为，这两者是具备可比性的，我们放在一起来看：动态生成 HTML 字符串的过程本质是对字符串的拼接，对性能的消耗是有限的；而虚拟 DOM 的构建和 diff 过程逻辑则相对复杂，它不可避免地涉及递归、遍历等耗时操作。因此在 JS 行为这个层面，模板渲染胜出。

模板渲染的步骤3，和虚拟 DOM 的步骤3 都属于 DOM 范畴的行为，两者具备可比性，因此我们仍然可以愉快地对比下去：模板渲染是全量更新，而虚拟 DOM 是差量更新。

乍一看好像差量更新一定比全量更新高效，但你需要考虑这样一种情况：数据内容变化非常大（或者说整个发生了改变），促使差量更新计算出来的结果和全量更新极为接近（或者说完全一样）。

在这种情况下，DOM 更新的工作量基本一致，而虚拟 DOM 却伴随着开销更大的 JS 计算，此时会出现的一种现象就是模板渲染和虚拟 DOM 在整体性能上难分伯仲：若两者最终计算出的 DOM 更新内容完全一致，那么虚拟 DOM 大概率不敌模板渲染；但只要两者在最终 DOM 操作量上拉开那么一点点的差距，虚拟 DOM 就将具备战胜模板渲染的底气。因为虚拟 DOM 的劣势主要在于 JS 计算的耗时，而 DOM 操作的能耗和 JS 计算的能耗根本不在一个量级，极少量的 DOM 操作耗费的性能足以支撑大量的 JS 计算。

当然，上面讨论的这种情况相对来说比较极端。在实际的开发中，更加高频的场景是这样的：我每次 setState 的时候只修改少量的数据，比如一个对象中的某几个属性，再比如一个数组中的某几个元素。在这样的场景下，模板渲染和虚拟 DOM 之间 DOM 操作量级的差距就完全拉开了，虚拟 DOM 将在性能上具备绝对的优势。

注意，此处的结论是“在 XXX 场景下，虚拟 DOM 相对于 XXX 具备性能优势”，它是有严格限定条件的。有人不到黄河心不死，可能又要问“那虚拟 DOM 对比 jQuery 呢？”“那虚拟 DOM 对比原生 DOM 呢？”。
我想说的是，性能问题不能一概而论，而且咱都讲到这个份上了，就不要再钻性能这个牛角尖了。jQuery、原生 DOM 在思维模式上来说和虚拟 DOM 截然不同，强行比较意义不大。
```

**虚拟 DOM 的价值不在性能，而在别处**，那么虚拟DOM的价值到底是什么呢

虚拟 DOM 解决的**关键问题**有以下两个：
1. 研发体验/研发效率的问题：这一点前面已经反复强调过，DOM操作模式的每一次革新，背后都是前端对效率和体验的进一步追求。**虚拟DOM的出现，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程**
2. 跨平台的问题：虚拟DOM是对真实渲染内容的一层抽象。若没有这一层抽象，那么视图层将和渲染平台紧密耦合在一起，为了描述同样的视图内容，你可能要分别在 Web 端和 Native 端写完全不同的两套甚至多套代码。但现在中间多了一层描述性的虚拟DOM，它描述的东西可以是真实DOM，也可以是iOS界面、安卓界面、小程序......同一套虚拟DOM，可以对接不同平台的渲染逻辑，从而实现“一次编码，多端运行”，如下图所示。其实说到底，跨平台也是研发提效的一种手段，它在思想上和1是高度呼应的

批量更新：“批量更新”在通用虚拟 DOM 库里是由 batch 函数来处理的。在差量更新速度非常快的情况下（比如极短的时间里多次操作同一个 DOM），用户实际上只能看到最后一次更新的效果。这种场景下，前面几次的更新动作虽然意义不大，但都会触发重渲染流程，带来大量不必要的高耗能操作。

这时就需要请 batch 来帮忙了，batch 的作用是缓冲每次生成的补丁集，它会把收集到的多个补丁集暂存到队列中，再将最终的结果交给渲染函数，最终实现集中化的 DOM 批量更新
