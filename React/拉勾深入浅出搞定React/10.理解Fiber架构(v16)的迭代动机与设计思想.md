### 一、背景

在理解Fiber架构之前，我们先来看看 React团队在“React哲学”中对React的定位：我们认为，React是用JavaScript构建快速响应的大型Web应用程序的首选方式

> “快速响应”，这 4 个字可以说是 React 团队在用户体验方面最为要紧的一个追求。关于这点，在 React 15 时代已经可见一斑：正是出于对“快速响应”的执着，React 才会想方设法把原本 O(n3) 的 Diff 时间复杂度优化到了前无古人的 O(n)

然而，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 **Stack Reconciler** 也渐渐在体验方面显出疲态。为了更进一步贯彻“快速响应”的原则，React 团队“壮士断腕”，在 16.x 版本中将其最为核心的 Diff 算法整个重写，使其以“**Fiber Reconciler**”的全新面貌示人

Q：Stack Reconciler 到底有着怎样根深蒂固的局限性，使得 React 不得不从架构层面做出改变

Q：Fiber 架构又是何方神圣，基于它来实现的调和过程又有什么不同

### 二、单线程的 JavaScript 与多线程的浏览器
对于多线程的浏览器来说，它除了要处理JavaScript线程以外，还需要处理包括事件系统、定时器/延时器、网络请求等各种各样的任务线程，这其中，自然也包括负责处理DOM的UI渲染线程

**而avaScript线程是可以操作DOM的**
这意味着什么呢？试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。**这就决定了JavaScript 线程和渲染线程必须是互斥的**：这两个线程不能够穿插执行，必须串行。**当其中一个线程执行时，另一个线程只能挂起等待**

具有相似特征的还有事件线程，浏览器的Event-Loop机制决定了事件任务是由一个异步队列来维持的。当事件被触发时，对应的任务不会立刻被执行，而是由事件线程把它添加到任务队列的末尾，等待JavaScript的同步代码执行完毕后，在空闲的时间里执行出队

在这样的机制下，若JavaScript线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，**带给用户的体验就是所谓的“卡顿”**。一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，事件线程也在等待JavaScript，这就导致你触发的事件也将是难以被响应的

这其实正是Stack Reconciler后期所面临的困局


