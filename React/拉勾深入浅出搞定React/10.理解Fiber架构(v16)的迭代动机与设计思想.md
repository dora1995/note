### 一、背景

在理解Fiber架构之前，我们先来看看 React团队在“React哲学”中对React的定位：我们认为，React是用JavaScript构建快速响应的大型Web应用程序的首选方式

> “快速响应”，这 4 个字可以说是 React 团队在用户体验方面最为要紧的一个追求。关于这点，在 React 15 时代已经可见一斑：正是出于对“快速响应”的执着，React 才会想方设法把原本 O(n3) 的 Diff 时间复杂度优化到了前无古人的 O(n)

然而，随着时间的推移和业务复杂度的提升，React 曾经被人们津津乐道的 **Stack Reconciler** 也渐渐在体验方面显出疲态。为了更进一步贯彻“快速响应”的原则，React 团队“壮士断腕”，在 16.x 版本中将其最为核心的 Diff 算法整个重写，使其以“**Fiber Reconciler**”的全新面貌示人

Q：Stack Reconciler 到底有着怎样根深蒂固的局限性，使得 React 不得不从架构层面做出改变

Q：Fiber 架构又是何方神圣，基于它来实现的调和过程又有什么不同

### 二、单线程的 JavaScript 与多线程的浏览器
对于多线程的浏览器来说，它除了要处理JavaScript线程以外，还需要处理包括事件系统、定时器/延时器、网络请求等各种各样的任务线程，这其中，自然也包括负责处理DOM的UI渲染线程

**而avaScript线程是可以操作DOM的**
这意味着什么呢？试想如果渲染线程和 JavaScript 线程同时在工作，那么渲染结果必然是难以预测的：比如渲染线程刚绘制好的画面，可能转头就会被一段 JavaScript 给改得面目全非。**这就决定了JavaScript 线程和渲染线程必须是互斥的**：这两个线程不能够穿插执行，必须串行。**当其中一个线程执行时，另一个线程只能挂起等待**

具有相似特征的还有事件线程，浏览器的Event-Loop机制决定了事件任务是由一个异步队列来维持的。当事件被触发时，对应的任务不会立刻被执行，而是由事件线程把它添加到任务队列的末尾，等待JavaScript的同步代码执行完毕后，在空闲的时间里执行出队

在这样的机制下，**若JavaScript线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待**，界面长时间不更新，**带给用户的体验就是所谓的“卡顿”**。一般页面卡顿的时候，你会做什么呢？我个人的习惯是更加频繁地在页面上点来点去，期望页面能够给我哪怕一点点的响应。遗憾的是，事件线程也在等待JavaScript，这就导致你触发的事件也将是难以被响应的

这其实正是Stack Reconciler后期所面临的困局

### 三、为什么会产生“卡顿”这样的困局

Stack Reconciler 所带来的一个无解的问题，正是JavaScript 对主线程的超时占用问题；这所以会有这样一个问题，是因为**Stack Reconciler 是一个同步的递归过程**

同步的递归过程，意味着一旦开始，除非遇到结束条件，否则就停不下来；在react15以及之前版本中，虚拟DOM树的数据结构载体是“树”，其diff算法的遍历思路，本质上是树的深度优先遍历的过程：会不断深入子节点进行对比，直到最深一层节点更新完毕，才慢慢向上返回

这个过程的**致命性在于它是同步的，不可以被打断**。当处理结构相对复杂、体量相对庞大的虚拟 DOM 树时，Stack Reconciler 需要的调和时间会很长，这就意味着 JavaScript 线程将长时间地霸占主线程，进而导致我们上文中所描述的渲染卡顿/卡死、交互长时间无响应等问题

#### 四、Fiber是如何解决问题的

 Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”。纤程的出现，意在对渲染过程实现更加精细的控制
 
 > Fiber 是一个多义词。从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写；从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM”；从工作流的角度来看，Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元

从架构角度来理解：
fiber目的：实现“增量渲染”，即把一个渲染任务分解成多个渲染任务，然后分到多个帧里面；不过严格来说，增量渲染其实也只是一种手段，实现增量渲染的目的，是为了实现任务的可中断、可恢复，并给不同的任务赋予不同的优先级，最终达成更加顺滑的用户体验

fiber架构核心：可中断，可恢复，优先级

在react16之前，react的渲染和更新阶段依赖的是两层架构：reconciler（找不同） -> renderer（渲染不同）；reconciler负责对比新老虚拟dom之间的变化，renderer负责将变化的部分应用到视图上，这个过程是严格同步的

在react16中，为了实现“可中断”，“优先级”，修改成了三层架构：scheduler（调度器：调度更新的优先级） -> reconciler（找不同） -> renderer（渲染不同）：在这个模式下，工作流变成：首先每个更新任务都会被赋予一个优先级，当更新任务抵达调度器时，高优先级的更新任务（A）会更快地被调度进reconciler；若此时有新的更新任务（B）抵达调度器，调度器会检查它的优先级，如果发现它的优先级高于当前任务A，那么当前处于reconciler层的A任务会被中断，调度器将B推入reconciler层；当B任务完成渲染后，新的一轮调度开始，之前中断的A任务将会重新推入recinciler层，继续渲染之旅，这便是“可恢复”


### 五、fiber架构对生命周期的影响

react16的生命周期分为三个阶段：

1.render阶段：纯净且没有副作用，可能被react暂停、终止或重新启动
2.pre-commit阶段：可以读取dom
3.commit阶段：可以使用dom，运行副作用

其中pre-commit和commit从大阶段上看都属于commit阶段；在render阶段，react主要在内存中做计算，明确dom树的更新点；而commit阶段，则负责把render阶段生成的更新真正地执行

所以有了以下差别：

react15：render开始 -> 不断地递归（停不下，同步） -> commit提交渲染
react16：render开始 -> 工作单元｜工作单元｜工作单元（异步）-> commit提交渲染

**新老两种架构对 React 生命周期的影响主要在 render 这个阶段，这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的**；在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是 0 感知

但是，工作单元（也就是任务）的重启将会伴随着对部分生命周期的重复执行，这些生命周期是：
- componentWillMount
- componentWillUpdate
- shouldComponentUpdate
- componentWillReceiveProps

而 “componentWill” 开头的三个生命周期，则常年被开发者以各种各样的姿势滥用，是副作用的“重灾区”；所以是为什么
