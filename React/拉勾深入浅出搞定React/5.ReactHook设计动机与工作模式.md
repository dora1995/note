> 真理：当我们由浅入深地认知一样新事物的时候，往往需要遵循“Why→What→How”这样的一个认知过程

是React团队在组件开发实践中，逐渐认知到的一个改进点，背后涉及对类组件与函数组件两种形式的思考与侧重

16.8版本推广

### 对比

何为类组件：ES6 Class写法，继承React.Component

何为函数组件/无状态组件：以函数形态存在的React组件，早期没有hook的加成，内部无法定义和维护state，智能接受外部props，故也叫做无状态组件

函数组件与类组件的对比（16版本之前）：无关优劣，只有不同：
- 类组件需要继承class，函数组件不用
- 类组件可以访问生命周期方法，函数组件不能
- 类组件可以获取实例化后的this，并基于this做操作，函数组件不能
- 类组件可以定义并维护state，函数组件不能
- 当然，这并不代表函数组件就输人家：**在hoos出现之前，类组件的能力边界明显强于函数组件，但不能推导出类组件强于函数组件**

> 当我们讨论这两种组件形式时，不应怀揣“孰优孰劣”这样的成见，而应该更多地去关注两者的不同，进而把不同的特性与不同的场景做连接，这样才能求得一个全面的、辩证的认知


### 重新理解类组件：包裹在面向对象思想下的“重装战舰”

react类组件中预置了相当多的“现有的东西”可以去调度，内部已经都准备好了一切

类组件是面向对象编程思想的一种表征，封装与继承；“大而全”的背后，**是不可忽视的学习成本**；而且有时候只需要实现较简单功能，有点大材小用了

由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得**类组件内部的逻辑难以实现拆分和复用**。如果你想要打破这个僵局，则需要进一步学习更加复杂的设计模式（比如高阶组件、Render Props 等），用更高的学习成本来交换一点点编码的灵活度


#### 深入理解函数组件：呼应 React 设计思想的“轻巧快艇”
相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等

> 函数组件会捕获 render 内部的状态，这是两类组件最大的不同：函数组件真正地把数据和渲染绑定到了一起；https://overreacted.io/how-are-function-components-different-from-classes/

**类组件和函数组件之间，纵有千差万别，但最不能够被我们忽视掉的，是心智模式层面的差异，是面向对象和函数式编程这两套不同的设计思想之间的差异**

函数组件更加契合 React 框架的设计理念：
![image](https://user-images.githubusercontent.com/53267289/126266612-c380d56b-fb72-4238-a6bc-4b93d7c9471d.png)

**函数组件能更好的保存传入状态，因为有闭包的存在，使得真正地把数据和渲染绑定到了一起；更加匹配其设计理念，有利于逻辑拆分与重用**

类组件存在的问题：
- 数据更新机制与快照

ReactHook本质：
- 能够使函数组件更强大/更灵活的钩子
- 带来了state管理等缺失的功能


### 对hook的整体认知

#### useState
为函数组件引入**一个**状态

#### useEffect
允许函数组件执行副作用操作，非对等生命周期

### why hook

没有标准答案：
- 告别难以理解的class：主要是this与生命周期 -> 不用再关心this
- 解决业务逻辑难以拆分的问题：逻辑一度与生命周期耦合在一起，导致复杂 -> 按照逻辑上的关联拆分到不同的函数组件中管理
- 使状态逻辑复用变得简单可行：以往是使用高阶组件等，容易引发嵌套地狱 -> 自定义hook
- 函数组件从设计思想上更加契合react的理念

### 保持清醒：hooks并非万能
事事无绝对，凡事皆有两面性。更何况 React 仅仅是推崇函数组件，并没有“拉踩”类组件，甚至还官宣了“类组件和函数组件将继续共存”这件事情。这些都在提醒我们，在认识到 Hooks 带来的利好的同时，还需要认识到它的局限性：
- Hooks 暂时还不能完全地为函数组件补齐类组件的能力
- “轻量”几乎是函数组件的基因，这可能会使它不能够很好地消化“复杂”，函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求
- Hooks 在使用层面有着严格的规则约束



参考文章：
https://overreacted.io/how-are-function-components-different-from-classes/
