React 应用也是前端应用，如果之前你知道一些前端项目普适的性能优化手段，比如**资源加载过程中的优化、减少重绘与回流、服务端渲染、启用CDN等**，那么这些手段对于 React 来说也是同样**奏效**的

不过对于 React 项目来说，它有一个区别于传统前端项目的重要特点，就是以 **React 组件的形式来组织逻辑**：组件允许我们将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。
因此，除了前面所提到的普适的前端性能优化手段之外，React 还有一些充满了自身特色的性能优化思路，
这些思路基本都围绕“组件性能优化”这个中心思想展开，其中最关键的 3 个思路：

1. 使用shouldComponentUpdate规避冗余的更新逻辑
2. PureComponent + immutable.js
3. React.memo + useMemo

一、shouldComponentUpdate

render 方法由于伴随着对虚拟 DOM 的构建和对比，过程可以说相当耗时。而在 React 当中，很多时候我们会不经意间就频繁地调用了 render。
为了避免不必要的 render 操作带来的性能开销，React 提供了 shouldComponentUpdate 这个口子。
React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行 re-render（重渲染）

只要父组件发生了更新，那么所有的子组件都会被无条件更新

同样的情况也适用于组件自身的更新：当组件自身调用了setState后，那么不管setState前后的状态内容是否真正发生了变化，它都会去走一遍更新流程

二、PureComponent

提前帮你安排好更新判定逻辑：使用shouldComponentUpdate对props和state进行**浅对比**

“浅比较”将针对值类型数据对比其值是否相等，而针对数组、对象等引用类型的数据则对比其引用是否相等

风险（对引用类型）：
- 若数据内容没变，但是引用变了，那么浅比较仍然会认为“数据发生了变化”，进而触发一次不必要的更新，导致过度渲染
- 若数据内容变了，但是引用没变，那么浅比较则会认为“数据没有发生变化”，进而阻断一次更新，导致不渲染

使用Immutable：所谓“持久性数据”，指的是这个数据只要被创建出来了，就不能被更改。我们对当前数据的任何修改动作，都会导致一个新的对象的返回

三、React.memo与useMemo

React.memo 会帮我们“记住”函数组件的渲染结果，在组件前后两次 props 对比结果一致的情况下，它会直接复用最近一次渲染的结果；浅比较；**只对比props的变化，对内部state不会有感知**

useMemo：更加“精细”的 memo：控制的是否需要重复执行某一段逻辑


