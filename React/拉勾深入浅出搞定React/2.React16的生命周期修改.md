对React15与16版本的生命周期进行探讨、对比和总结

> 如果对设计模式有所了解的话，就会知道，一个 API 并非越庞大越复杂才越优秀。或者说得更直接一点，庞大和复杂的 API 往往会带来维护层面的“灾难

React基本原理中两个极为关键的概念：

- 虚拟DOM：核心算法的基石：createElement生成虚拟DOM，调用React.render方法实现转换 -> 组件更新再次生成新的虚拟DOM，然后借助diff算法定位两次虚拟DOM的差异，然后做定向更新
- 组件化：工程化思想的落地，封闭（组建更新是可以独立，互不影响的）与开放（通过单向数据流来进行通信）

**生命周期的本质：组件的灵魂与躯干**

渲染工作流：组件数据改变到组件实际更新发生的过程

render函数的重要性，组件与虚拟DOM都围绕在它

### React15的生命周期
```
constructor()
componentWillReceiveProps()
shouldComponentUpdate()
componentWillMount()
componentWillUpdate()
componentDidUpdate()
componentDidMount()
render()
componentWillUnmount()
```
他们的执行顺序是这样的：
![image](https://user-images.githubusercontent.com/53267289/125733416-37a92aea-c127-4d0c-a58b-13c18224910d.png)

如果父组件导致组件重新渲染，即使props没有更改也会调用 componentReceiveProps；如果只想处理更改，要进行对比；由父组件的更新触发的


测试


### React16的生命周期

很棒的一个流程链接：https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

> 这里之所以特意将版本号精确到了小数点后面一位，是因为在React 16.4之后，React 生命周期在之前版本的基础上又经历了一次微调

```
constructor()
getDerivedStateFormProps()*
shouldComponentUpdate()
render()
componentDidMount()
getSnapshotBeforeUpdate()*
componentDidUpdate
componentWillUnmount()
```

#### getDerivedStateFormProps
- getDerivedStateFormProps是一个静态方法，内部是访问不到this的
- 该方法接收两个参数props，state，分别代表当前组件接收到的来自父组件的props和当前组件自身的state
- 需要一个对象格式的返回值，React会根据它来更新组件的state：**非覆盖**，针对某个属性的定向更新
- 在16.3时，只有父组件更新才会触发；在16.3后，任何因素触发的组件更新都会触发

#### getSnapshotBeforeUpdate
- 返回值会作为第三个参数给到 componentDidUpdate
- 它的执行时机是在 render 方法之后，真实 DOM 更新之前，在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state&props 信息

### 15与16的对比
1. 挂载阶段，componentWillMount移除，getDerivedStateFormProps新增：getDerivedStateFromProps 这个 API，其设计的初衷不是试图替换掉 componentWillMount，而是试图替换掉 componentWillReceiveProps，因此它有且仅有一个用途：**使用 props 来派生/更新 state**


