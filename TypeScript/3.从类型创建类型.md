TypeScript 的类型系统非常强大，因为它允许根据其他类型来表达类型；通过组合各种类型运算符，我们可以以简洁、可维护的方式表达复杂的操作和值，主要有：
- 泛型：带参数的类型
- Keyof Type Operator： 使用keyof运算符创建新类型
- Typeof 类型运算符：使用typeof运算符创建新类型
- 索引访问类型：使用Type['a']语法访问类型的子集
- 条件类型：类型类似于类型系统中的 if 语句
- 映射类型：通过映射现有类型中的每个属性来创建类型
- 模板文字类型：通过模板文字字符串更改属性的映射类型

### 1.泛型
```
function identity<Type>(arg: Type): Type {
  return arg;
}

let output = identity<string>("myString");
// 或者直接使用类型推断
let output = identity("myString");
```

```
interface GenericIdentityFn {
  <Type>(arg: Type): Type;
}
 
function identity<Type>(arg: Type): Type {
  return arg;
}
 
let myIdentity: GenericIdentityFn = identity;
```

```
interface Lengthwise {
  length: number;
}
 
function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
  console.log(arg.length); // Now we know it has a .length property, so no more error
  return arg;
}

function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key];
}
```

在 TypeScript 中使用泛型创建工厂时，需要通过它们的构造函数来引用类类型
```
function create<Type>(c: { new (): Type }): Type {
  return new c();
}
```


### 2.Keyof
当右边是对象时，会直接用字面量表示：
```
type Point = { x: number; y: number };
type P = keyof Point;
// type P = keyof Point
```

当右边是具有string或number索引签名，keyof则将返回这些类型：
```
type Arrayish = { [n: number]: unknown };
type A = keyof Arrayish;
// type A = number
 
type Mapish = { [k: string]: boolean };
type M = keyof Mapish;
// type M = string | number
```

keyof 当与映射类型结合使用时，类型变得特别有用



