### 一、目标
- 理解浏览器重绘与回流的机制
- 如何通过代码去避免消耗

### 二、案例分析
- 需要结合performance工具来查看，模拟环境，善用工具
- 打开layers工具，在右边三个点moretools里面
- 打开Rendering，勾选paint flashing查看在正在重绘/回流的事物
- layers不能滥用，因为在渲染过程中很消耗性能
- **不是有方案就很牛逼，一定要具体情况具体分析，并且要进行前后对比，不要进行负优化！**


Q：css性能会让javascript变慢吗
两者是相互堵塞的，原因在上节有讲到；分别由javascript解析线程和UI渲染线程处理，浏览器限制同一时间只能有一个线程被执行；频繁触发重绘与回流，会导致UI频繁渲染，最终导致js变慢

Q：在渲染性能较差的环境下（移动端），能不能通过其他方式来替代回流

![image](https://user-images.githubusercontent.com/53267289/137670633-8637d8a9-e179-4600-a441-1869e770d4e5.png)
**将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流的影响只会在这个图层中**；缺点：图层合成的过程是很消耗运算量的


Q：如何将DOM元素变成新的独立图层
A：使用css；在chrome中，可以：
- 使用3D或透视变换css属性（perspective transform）
- 使用加速视频解码的video节点
- 拥有3d（WebGL）上下文或加速的2D上下文的canvas节点
- 混合插件（如flash）
- 对自己的opacity做css动画或使用一个动画webkit变换的元素
- 拥有加速css过滤器的元素
- 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）
- 元素有一个z-inde较低包含一个复合层的兄弟元素（即该元素在复合层上渲染）

### 优化点
1. 用translate替代top改变，少一次回流
2. 用opacity替代visibility；但是同个图层中可能对其他元素会有影响，导致重绘；最好是单独抽成一个图层
3. 不要一条一条地修改dom的样式，预先定义好class，然后一次性修改
4. 把dom离线后修改；比如先把dom给display:none（一次reflow），然后怎么改都不影响，最后再显示出来
5. **不要把dom节点的属性值放在一个循环里当成循环里的变量，会触发回流获取属性**，如offsetHeight，offsetWidth
6. 不要使用table布局，可能一个很小的改动会造成整个table的重新布局
7. 动画实现的速度的选择
8. 对于动画新建图层
9. **启用gpu硬件加速**，有缺点，需要考量：比如3d，transform: translate3d(0, 0, 0)

